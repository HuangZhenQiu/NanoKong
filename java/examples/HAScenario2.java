import java.io.*;
import nanovm.avr.*;
import nanovm.wkpf.*;
import nanovm.lang.Math;

public class HAScenario2 {
  // =========== Begin: Constant part, not affected by the application.
  public static void main(String[] args) {
    System.out.println("HAScenario 1");

    WKPF.loadComponentToWuObjectAddrMap(componentInstanceToWuObjectAddrMap);
    WKPF.loadLinkDefinitions(linkDefinitions);
    initialiseLocalWuObjects();

    // ----- MAIN LOOP -----
    System.out.println("HAScenario - Entering main loop");
    while(true) {
      VirtualWuObject wuclass = WKPF.select();
      if (wuclass != null) {
        wuclass.update();
      }      
    }
  }
  // =========== End: Constant part, not affected by the application.
  
  // =========== Begin: Generated by the compiler from application WuML
  private static final short COMPONENT_INSTANCE_ID_INPUTCONTROLLER1 = 0;
  private static final short COMPONENT_INSTANCE_ID_LIGHTSENSOR1 = 1;
  private static final short COMPONENT_INSTANCE_ID_THRESHOLD1 = 2;
  private static final short COMPONENT_INSTANCE_ID_LIGHT1 = 3;
  private static final short COMPONENT_INSTANCE_ID_OCCUPANCY1 = 4;
  private static final short COMPONENT_INSTANCE_ID_ANDGATE1 = 5;

  private final static byte[] componentInstanceToWuObjectAddrMap = { // Indexed by component instance id.
    (byte)1, (byte)0x1, // Component 0: input controller    @ node 1, port 1
    (byte)1, (byte)0x2, // Component 1: light sensor        @ node 1, port 2
    (byte)3, (byte)0x3, // Component 2: threshold           @ node 3, port 3
    (byte)3, (byte)0x4, // Component 3: light               @ node 3, port 4
    (byte)1, (byte)0x5, // Component 4: occupancy           @ node 1, port 5
    (byte)3, (byte)0x6  // Component 5: and gate            @ node 3, port 6
  };


  private final static byte[] linkDefinitions = { // Note: Component instance id and wuclass id are little endian
    // Note: using WKPF constants now, but this should be generated as literal bytes by the WuML->Java compiler.
    // Connect input controller to threshold
    (byte)COMPONENT_INSTANCE_ID_INPUTCONTROLLER1, (byte)0, (byte)WKPF.PROPERTY_NUMERIC_CONTROLLER_OUTPUT,
    (byte)COMPONENT_INSTANCE_ID_THRESHOLD1, (byte)0, (byte)WKPF.PROPERTY_THRESHOLD_THRESHOLD,
    (byte)WKPF.WUCLASS_THRESHOLD, (byte)0,

    // Connect light sensor to threshold
    (byte)COMPONENT_INSTANCE_ID_LIGHTSENSOR1, (byte)0, (byte)WKPF.PROPERTY_LIGHT_SENSOR_CURRENT_VALUE,
    (byte)COMPONENT_INSTANCE_ID_THRESHOLD1, (byte)0, (byte)WKPF.PROPERTY_THRESHOLD_VALUE,
    (byte)WKPF.WUCLASS_THRESHOLD, (byte)0,

    // Connect threshold to and gate
    (byte)COMPONENT_INSTANCE_ID_THRESHOLD1, (byte)0, (byte)WKPF.PROPERTY_THRESHOLD_OUTPUT,
    (byte)COMPONENT_INSTANCE_ID_ANDGATE1, (byte)0, (byte)WKPF.PROPERTY_AND_GATE_IN1,
    (byte)WKPF.WUCLASS_AND_GATE, (byte)0,

    // Connect occupancy to and gate
    (byte)COMPONENT_INSTANCE_ID_OCCUPANCY1, (byte)0, (byte)VirtualOccupancySensorWuObject.PROPERTY_OCCUPANCY_SENSOR_OCCUPIED,
    (byte)COMPONENT_INSTANCE_ID_ANDGATE1, (byte)0, (byte)WKPF.PROPERTY_AND_GATE_IN2,
    (byte)WKPF.WUCLASS_AND_GATE, (byte)0,

    // Connect and gate to light
    (byte)COMPONENT_INSTANCE_ID_ANDGATE1, (byte)0, (byte)WKPF.PROPERTY_AND_GATE_OUTPUT,
    (byte)COMPONENT_INSTANCE_ID_LIGHT1, (byte)0, (byte)WKPF.PROPERTY_LIGHT_ONOFF,
    (byte)WKPF.WUCLASS_LIGHT, (byte)0
  };

  private static void initialiseLocalWuObjects() {
    WKPF.registerWuClass(WKPF.WUCLASS_AND_GATE, VirtualANDGateWuObject.properties);
    WKPF.registerWuClass(VirtualOccupancySensorWuObject.WUCLASS_OCCUPANCY_SENSOR, VirtualOccupancySensorWuObject.properties);

    // Setup the temperature sensor
    if (WKPF.isLocalComponent(COMPONENT_INSTANCE_ID_LIGHTSENSOR1)) { 
      System.out.println("HASCENARIO INIT: Set light sensor to 1000ms refresh rate");
      WKPF.setPropertyShort(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, WKPF.PROPERTY_LIGHT_SENSOR_SAMPLING_RATE, (short)1000); // Sample the temperature every 5 seconds
    }
    // Setup the numeric input
    if (WKPF.isLocalComponent(COMPONENT_INSTANCE_ID_INPUTCONTROLLER1)) { 
      System.out.println("HASCENARIO INIT: Set input controller to default value of 127");
      WKPF.setPropertyShort(COMPONENT_INSTANCE_ID_INPUTCONTROLLER1, WKPF.PROPERTY_NUMERIC_CONTROLLER_OUTPUT, (short)127); // Default threshold: 127
    }
    // Create and setup the threshold wuobject
    if (WKPF.isLocalComponent(COMPONENT_INSTANCE_ID_THRESHOLD1)) {
      System.out.println("HASCENARIO INIT: Create threshold and set operator to <=");
      WKPF.createWuObject((short)WKPF.WUCLASS_THRESHOLD, WKPF.getPortNumberForComponent(COMPONENT_INSTANCE_ID_THRESHOLD1), null);
      WKPF.setPropertyShort(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_OPERATOR, WKPF.PROPERTY_THRESHOLD_OPERATOR_LTE); // Threshold operator: <=
    }
    // Register virtual and gate wuclass and create an wuobject
    if (WKPF.isLocalComponent(COMPONENT_INSTANCE_ID_ANDGATE1)) {
      System.out.println("HASCENARIO INIT: Create and gate");
      VirtualWuObject wuclassInstanceANDGate = new VirtualANDGateWuObject();
      WKPF.createWuObject((short)WKPF.WUCLASS_AND_GATE, WKPF.getPortNumberForComponent(COMPONENT_INSTANCE_ID_ANDGATE1), wuclassInstanceANDGate);
    }
    // Register virtual occupancy sensor wuclass and create an wuobject
    if (WKPF.isLocalComponent(COMPONENT_INSTANCE_ID_OCCUPANCY1)) {
      System.out.println("HASCENARIO INIT: Create occupancy sensor and set default value to occupied");
      VirtualWuObject wuclassInstanceOccupancy = new VirtualOccupancySensorWuObject();
      WKPF.createWuObject((short)VirtualOccupancySensorWuObject.WUCLASS_OCCUPANCY_SENSOR, WKPF.getPortNumberForComponent(COMPONENT_INSTANCE_ID_OCCUPANCY1), wuclassInstanceOccupancy);
      WKPF.setPropertyBoolean(COMPONENT_INSTANCE_ID_OCCUPANCY1, VirtualOccupancySensorWuObject.PROPERTY_OCCUPANCY_SENSOR_OCCUPIED, true); // Default: occupied
    }
    // =========== End: Generated by the compiler from application WuML
  }
}
