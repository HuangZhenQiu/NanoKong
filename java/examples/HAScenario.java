import java.io.*;
import nanovm.avr.*;
import nanovm.wkpf.*;
import nanovm.lang.Math;

public class HAScenario {
  // =========== Constant part, not affected by the application.
  private static int myNodeId;

  private static boolean matchDirtyProperty(int componentInstanceId, byte propertyNumber) {
    System.out.println("===== MATCH -----");
    System.out.println(componentInstanceToEndpointMapping[0].nodeId);
    System.out.println(componentInstanceToEndpointMapping[1].nodeId);
    System.out.println(componentInstanceToEndpointMapping[2].nodeId);
    System.out.println(componentInstanceToEndpointMapping[3].nodeId);
    System.out.println("===== MATCH -----2");
    Endpoint endpoint = ComponentInstancetoEndpoint(componentInstanceId);
    return endpoint.nodeId == myNodeId
        && endpoint.portNumber == WKPF.getDirtyPropertyPortNumber()
        && propertyNumber == WKPF.getDirtyPropertyNumber();
  }
  private static void setPropertyShort(int componentInstanceId, byte propertyNumber, short value) {      
      Endpoint endpoint = ComponentInstancetoEndpoint(componentInstanceId);
      WKPF.setPropertyShort(endpoint.nodeId, endpoint.portNumber, propertyNumber, endpoint.profileId, value);
  }
  private static void setPropertyBoolean(int componentInstanceId, byte propertyNumber, boolean value) {
      Endpoint endpoint = ComponentInstancetoEndpoint(componentInstanceId);
      WKPF.setPropertyBoolean(endpoint.nodeId, endpoint.portNumber, propertyNumber, endpoint.profileId, value);
  }

  public static Endpoint ComponentInstancetoEndpoint(int componentInstanceId) {
    // INITIAL STATIC VERSION: This could later be replaced by something more dynamic, for now the table is a hardcoded constant
    return componentInstanceToEndpointMapping[componentInstanceId];
  }

  // =========== Generated by the compiler
  private static final int COMPONENT_INSTANCE_ID_THERMOSTATCONTROLLER1 = 0;
  private static final int COMPONENT_INSTANCE_ID_LIGHTSENSOR1 = 1;
  private static final int COMPONENT_INSTANCE_ID_THRESHOLD1 = 2;
  private static final int COMPONENT_INSTANCE_ID_LIGHT1 = 3;
  
  private static int lastPropagatedValue;
  private static short tmpDummy = 0;
  
  private static final Endpoint[] componentInstanceToEndpointMapping = { // Indexed by component instance id.
    new Endpoint((byte)77, (byte)1, WKPF.PROFILE_NUMERIC_CONTROLLER), // Thermostat
    new Endpoint((byte)77, (byte)2, WKPF.PROFILE_LIGHT_SENSOR), // Temperature sensor
    new Endpoint((byte)77, (byte)3, WKPF.PROFILE_THRESHOLD), // Threshold
    new Endpoint((byte)77, (byte)4, WKPF.PROFILE_LIGHT), // Light
  };
  
  public static void main(String[] args) {
    System.out.println("HAScenario");
    
/*    while(true) {
      setPropertyBoolean(COMPONENT_INSTANCE_ID_LIGHT1, WKPF.PROPERTY_LIGHT_ONOFF, false);
      Timer.wait(100);
      setPropertyBoolean(COMPONENT_INSTANCE_ID_LIGHT1, WKPF.PROPERTY_LIGHT_ONOFF, true);
      Timer.wait(100);
    }*/

    myNodeId = WKPF.getMyNodeId();

    // ----- REGISTER VIRTUAL PROFILES -----
    // Won't work now since we already have a native profile
    // WKPF.registerProfile((short)WKPF.PROFILE_THRESHOLD, VirtualThresholdProfile.properties, (byte)VirtualThresholdProfile.properties.length);


    // ----- INIT -----
    // INITIAL STATIC VERSION: This should later be replaced by return value from WKPF.wait so the framework can dynamically allocate a new profile
    // Setup the temperature sensor
    if (ComponentInstancetoEndpoint(COMPONENT_INSTANCE_ID_LIGHTSENSOR1).nodeId == myNodeId) { 
      setPropertyShort(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, WKPF.PROPERTY_COMMON_REFRESHRATE, (short)5000); // Sample the temperature every 5 seconds
    }
    // Setup the numeric input
    if (ComponentInstancetoEndpoint(COMPONENT_INSTANCE_ID_THERMOSTATCONTROLLER1).nodeId == myNodeId) { 
      setPropertyShort(COMPONENT_INSTANCE_ID_THERMOSTATCONTROLLER1, WKPF.PROPERTY_NUMERIC_CONTROLLER_OUTPUT, (short)127); // Sample the temperature every 5 seconds
    }
    // Create and setup the virtual threshold
    if (ComponentInstancetoEndpoint(COMPONENT_INSTANCE_ID_THRESHOLD1).nodeId == myNodeId) {
      VirtualProfile profileInstanceThreshold = new VirtualThresholdProfile();
      WKPF.createEndpoint((short)WKPF.PROFILE_THRESHOLD, ComponentInstancetoEndpoint(COMPONENT_INSTANCE_ID_THRESHOLD1).portNumber, profileInstanceThreshold);
      setPropertyShort(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_OPERATOR, VirtualThresholdProfile.OPERATOR_LT); // Sample the temperature every 5 seconds
    }

    // ----- MAIN LOOP -----
    System.out.println("HAScenario - Entering main loop");
    while(true) {
      VirtualProfile profile = WKPF.select();
      if (profile != null) {
        profile.update();
      }
      propagateDirtyProperties();
      
      // TODONR: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
      tmpDummy += 1;
//      System.out.println("HAScenario - updating dummy variable to trigger lightsensor update ");
      setPropertyShort(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, (byte)(WKPF.PROPERTY_LIGHT_SENSOR_CURRENT_VALUE+1), tmpDummy);
      byte x = WKPF.getErrorCode();
      System.out.println("============Result: " + x);
      Timer.wait(500);
    }
  }

  public static void propagateDirtyProperties() {
    System.out.println("HAScenario - start propagateDirtyProperties");
    while(WKPF.loadNextDirtyProperty()) {
      
      if (matchDirtyProperty(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, WKPF.PROPERTY_LIGHT_SENSOR_CURRENT_VALUE)) {
        System.out.println("HAScenario - propagating lightsensor.currentvalue");

/*  TODONR: Math.abs doesn't work
      short value = WKPF.getDirtyPropertyShortValue();
        if (Math.abs(lastPropagatedValue - value) > 2) {
          lastPropagatedValue = value;
          setPropertyShort(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_VALUE, value);
        } */
      setPropertyShort(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_VALUE, WKPF.getDirtyPropertyShortValue());
      
      } else if (matchDirtyProperty(COMPONENT_INSTANCE_ID_THERMOSTATCONTROLLER1, WKPF.PROPERTY_NUMERIC_CONTROLLER_OUTPUT)) {
        System.out.println("HAScenario - propagating numericcontroller.output");
        setPropertyShort(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_THRESHOLD, WKPF.getDirtyPropertyShortValue());

      } else if (matchDirtyProperty(COMPONENT_INSTANCE_ID_THRESHOLD1, WKPF.PROPERTY_THRESHOLD_OUTPUT)) {
        System.out.println("HAScenario - propagating threshold.output");
        setPropertyBoolean(COMPONENT_INSTANCE_ID_LIGHT1, WKPF.PROPERTY_LIGHT_ONOFF, WKPF.getDirtyPropertyBooleanValue());
      }
    }
    System.out.println("HAScenario - end propagateDirtyProperties");
  }
}
