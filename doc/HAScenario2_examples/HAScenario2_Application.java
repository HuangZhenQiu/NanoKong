import java.io.*;
import nanovm.avr.*;
import nanovm.wkpf.*;
import nanovm.lang.Math;

public class HAScenario2 {
  // =========== Begin: Constant part, not affected by the application.
  private static int myNodeId;

  // TODONR: these could be changed to native methods for performance reasons (but they're only used in initialisation, so it's not too important)
  private static byte getPortNumberForComponent(short componentId) {
    return componentInstanceToEndpointMap[componentId*2 + 1];
  }
  private static boolean isLocalComponent(short componentId) {    
    int nodeId=componentInstanceToEndpointMap[componentId*2];
    return nodeId == myNodeId;
  }
  // =========== End: Constant part, not affected by the application.
  
  // =========== Begin: Generated by the translator from application WuML
  /* Component instance IDs:
  INPUTCONTROLLER1 = 0;
  LIGHTSENSOR1 = 1;
  THRESHOLD1 = 2;
  LIGHT1 = 3;
  OCCUPANCY1 = 4;
  ANDGATE1 = 5;
  */

  private final static byte[] linkDefinitions = {
    // Note: Component instance id and profile id are little endian
    // Note: using WKPF constants now, but this should be generated as literal bytes by the WuML->Java compiler.
    // Connect input controller to threshold
    (byte)0, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_INPUTCONTROLLER1, PROPERTY_NUMERIC_CONTROLLER_OUTPUT */
    (byte)2, (byte)0, (byte)1, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_THRESHOLD */
    (byte)1, (byte)0, /* PROFILE_THRESHOLD */

    // Connect light sensor to threshold
    (byte)1, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_LIGHTSENSOR1, PROPERTY_LIGHT_SENSOR_CURRENT_VALUE */
    (byte)2, (byte)0, (byte)2, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_VALUE */
    (byte)1, (byte)0, /* PROFILE_THRESHOLD */

    // Connect threshold to and gate
    (byte)2, (byte)0, (byte)3, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_OUTPUT */
    (byte)5, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_IN1 */
    (byte)0, (byte)6, /* PROFILE_AND_GATE */

    // Connect occupancy to and gate
    (byte)4, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_OCCUPANCY1, PROPERTY_OCCUPANCY_SENSOR_OCCUPIED */
    (byte)5, (byte)0, (byte)1, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_IN2 */
    (byte)0, (byte)6, /* PROFILE_AND_GATE */

    // Connect and gate to light
    (byte)5, (byte)0, (byte)2, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_OUTPUT */
    (byte)3, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_LIGHT1, PROPERTY_LIGHT_ONOFF */
    (byte)0, (byte)4 /* PROFILE_LIGHT */
  };
  // =========== End: Generated by the translator from application WuML

  // =========== Begin: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
  private static short tmpDummy = 0;
  // =========== End: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.

  // =========== Begin: Constant part, not affected by the application.
  public static void main(String[] args) {
    System.out.println("HAScenario 2");

    myNodeId = WKPF.getMyNodeId();
    System.out.println("MY NODE ID:" + myNodeId);

    WKPF.loadLinkDefinitions(linkDefinitions);
    if (WKPF.getErrorCode() == WKPF.OK)
      System.out.println("Registered link definitions.");
    else
      System.out.println("Error while Registering link definitions: " + WKPF.getErrorCode());

    WKPF.loadComponentToEndpointMap(HAScenario2_Mapping.componentInstanceToEndpointMap);
    if (WKPF.getErrorCode() == WKPF.OK)
      System.out.println("Registered component to endpoint map.");
    else
      System.out.println("Error while registering component to endpoint map: " + WKPF.getErrorCode());
    // =========== End: Constant part, not affected by the application.
    
      
    // ----- INIT -----
    // =========== Begin: Generated by the translator from application WuML
    if (isLocalComponent(0)) { /* Component COMPONENT_INSTANCE_ID_INPUTCONTROLLER1 */
      System.out.println("HASCENARIO INIT: Set input controller to default value of 127");
      WKPF.setPropertyShort(0, 0 /* PROPERTY_NUMERIC_CONTROLLER_OUTPUT */, (short)127); // Default threshold: 127
    }
    if (isLocalComponent(1)) { /* Component COMPONENT_INSTANCE_ID_LIGHTSENSOR1 */
      System.out.println("HASCENARIO INIT: Set light sensor to 5000ms refresh rate");
      WKPF.setPropertyShort(1, 0 /* PROPERTY_COMMON_REFRESHRATE */, (short)5000); // Sample the temperature every 5 seconds (this doesn't work yet)
    }
    if (isLocalComponent(2)) { /* Component COMPONENT_INSTANCE_ID_THRESHOLD1 */
      System.out.println("HASCENARIO INIT: Create threshold and set operator to <=");
      WKPF.createEndpoint((short)1 /* PROFILE_THRESHOLD */, getPortNumberForComponent(2), null);
      WKPF.setPropertyShort(2, 0 /* PROPERTY_THRESHOLD_OPERATOR */, 3 /* PROPERTY_THRESHOLD_OPERATOR_LTE */); // Threshold operator: <=
    }
    if (isLocalComponent(3)) { /* Component COMPONENT_INSTANCE_ID_LIGHT1 */
      // Native, builtin endpoint, no need to create.
    }
    if (isLocalComponent(5)) { /* Component COMPONENT_INSTANCE_ID_ANDGATE1 */
      System.out.println("HASCENARIO INIT: Create and gate");
      WKPF.registerProfile(VirtualANDGateProfile.PROFILE_AND_GATE, VirtualANDGateProfile.properties);
      VirtualProfile profileInstanceANDGate = new VirtualANDGateProfile();
      WKPF.createEndpoint((short)VirtualANDGateProfile.PROFILE_AND_GATE, getPortNumberForComponent(5), profileInstanceANDGate);
    }
    if (isLocalComponent(4)) { /* Component COMPONENT_INSTANCE_ID_OCCUPANCY1 */
      System.out.println("HASCENARIO INIT: Create occupancy sensor and set default value to occupied");
      WKPF.registerProfile(VirtualOccupancySensorProfile.PROFILE_OCCUPANCY_SENSOR, VirtualOccupancySensorProfile.properties);
      VirtualProfile profileInstanceOccupancy = new VirtualOccupancySensorProfile();
      WKPF.createEndpoint((short)VirtualOccupancySensorProfile.PROFILE_OCCUPANCY_SENSOR, getPortNumberForComponent(4), profileInstanceOccupancy);
      WKPF.setPropertyBoolean(4, VirtualOccupancySensorProfile.PROPERTY_OCCUPANCY_SENSOR_OCCUPIED, true); // Default: occupied
    }
    // =========== End: Generated by the translator from application WuML

    // =========== Begin: Constant part, not affected by the application.
    // ----- MAIN LOOP -----
    System.out.println("HAScenario - Entering main loop");
    while(true) {
      VirtualProfile profile = WKPF.select();
      if (profile != null) {
        profile.update();
      }
      // =========== End: Constant part, not affected by the application.

      // =========== Begin: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
      if (isLocalComponent(COMPONENT_INSTANCE_ID_LIGHTSENSOR1)) { 
        tmpDummy += 1;
        System.out.println("HAScenario - updating dummy variable to trigger lightsensor update: " + tmpDummy);
        WKPF.setPropertyShort(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, (byte)(WKPF.PROPERTY_LIGHT_SENSOR_CURRENT_VALUE+1), tmpDummy);
        System.out.println("HAScenario - updating dummy variable to trigger lightsensor update, result: " + WKPF.getErrorCode());
        if (WKPF.getErrorCode() != WKPF.OK)
          System.out.println("Error: " + WKPF.getErrorCode());
      }
      Timer.wait(1000);
      // =========== End: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
    }
  }
}
