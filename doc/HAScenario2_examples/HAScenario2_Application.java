import java.io.*;
import nanovm.avr.*;
import nanovm.wkpf.*;
import nanovm.lang.Math;

public class HAScenario2 {
  // =========== Begin: Constant part, not affected by the application.
  private static int myNodeId;

  // TODONR: these could be changed to native methods for performance reasons (but they're only used in initialisation, so it's not too important)
  private static byte getPortNumberForComponent(short componentId) {
    return componentInstanceToWuObjectAddrMap[componentId*2 + 1];
  }
  private static boolean isLocalComponent(short componentId) {    
    int nodeId=componentInstanceToWuObjectAddrMap[componentId*2];
    return nodeId == myNodeId;
  }
  // =========== End: Constant part, not affected by the application.
  
  // =========== Begin: Generated by the translator from application WuML
  /* Component instance IDs:
  INPUTCONTROLLER1 = 0;
  LIGHTSENSOR1 = 1;
  THRESHOLD1 = 2;
  LIGHT1 = 3;
  OCCUPANCY1 = 4;
  ANDGATE1 = 5;
  */

  private final static byte[] linkDefinitions = {
    // Note: Component instance id and wuclass id are little endian
    // Note: using WKPF constants now, but this should be generated as literal bytes by the WuML->Java compiler.
    // Connect input controller to threshold
    (byte)0, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_INPUTCONTROLLER1, PROPERTY_NUMERIC_CONTROLLER_OUTPUT */
    (byte)2, (byte)0, (byte)1, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_THRESHOLD */
    (byte)1, (byte)0, /* WUCLASS_THRESHOLD */

    // Connect light sensor to threshold
    (byte)1, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_LIGHTSENSOR1, PROPERTY_LIGHT_SENSOR_CURRENT_VALUE */
    (byte)2, (byte)0, (byte)2, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_VALUE */
    (byte)1, (byte)0, /* WUCLASS_THRESHOLD */

    // Connect threshold to and gate
    (byte)2, (byte)0, (byte)3, /* COMPONENT_INSTANCE_ID_THRESHOLD1, PROPERTY_THRESHOLD_OUTPUT */
    (byte)5, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_IN1 */
    (byte)0, (byte)6, /* WUCLASS_AND_GATE */

    // Connect occupancy to and gate
    (byte)4, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_OCCUPANCY1, PROPERTY_OCCUPANCY_SENSOR_OCCUPIED */
    (byte)5, (byte)0, (byte)1, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_IN2 */
    (byte)0, (byte)6, /* WUCLASS_AND_GATE */

    // Connect and gate to light
    (byte)5, (byte)0, (byte)2, /* COMPONENT_INSTANCE_ID_ANDGATE1, PROPERTY_AND_GATE_OUTPUT */
    (byte)3, (byte)0, (byte)0, /* COMPONENT_INSTANCE_ID_LIGHT1, PROPERTY_LIGHT_ONOFF */
    (byte)0, (byte)4 /* WUCLASS_LIGHT */
  };
  // =========== End: Generated by the translator from application WuML

  // =========== Begin: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
  private static short tmpDummy = 0;
  // =========== End: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.

  // =========== Begin: Constant part, not affected by the application.
  public static void main(String[] args) {
    System.out.println("HAScenario 2");

    myNodeId = WKPF.getMyNodeId();
    System.out.println("MY NODE ID:" + myNodeId);

    WKPF.loadLinkDefinitions(linkDefinitions);
    if (WKPF.getErrorCode() == WKPF.OK)
      System.out.println("Registered link definitions.");
    else
      System.out.println("Error while Registering link definitions: " + WKPF.getErrorCode());

    WKPF.loadComponentToWuObjectAddrMap(HAScenario2_Mapping.componentInstanceToWuObjectAddrMap);
    if (WKPF.getErrorCode() == WKPF.OK)
      System.out.println("Registered component to wuobject map.");
    else
      System.out.println("Error while registering component to wuobject map: " + WKPF.getErrorCode());
    // =========== End: Constant part, not affected by the application.
    
      
    // ----- INIT -----
    // =========== Begin: Generated by the translator from application WuML
    if (isLocalComponent(0)) { /* Component COMPONENT_INSTANCE_ID_INPUTCONTROLLER1 */
      System.out.println("HASCENARIO INIT: Set input controller to default value of 127");
      WKPF.setPropertyShort(0, 0 /* PROPERTY_NUMERIC_CONTROLLER_OUTPUT */, (short)127); // Default threshold: 127
    }
    if (isLocalComponent(1)) { /* Component COMPONENT_INSTANCE_ID_LIGHTSENSOR1 */
      System.out.println("HASCENARIO INIT: Set light sensor to 5000ms refresh rate");
      WKPF.setPropertyShort(1, 0 /* PROPERTY_COMMON_REFRESHRATE */, (short)5000); // Sample the temperature every 5 seconds (this doesn't work yet)
    }
    if (isLocalComponent(2)) { /* Component COMPONENT_INSTANCE_ID_THRESHOLD1 */
      System.out.println("HASCENARIO INIT: Create threshold and set operator to <=");
      WKPF.createWuObject((short)1 /* WUCLASS_THRESHOLD */, getPortNumberForComponent(2), null);
      WKPF.setPropertyShort(2, 0 /* PROPERTY_THRESHOLD_OPERATOR */, 3 /* PROPERTY_THRESHOLD_OPERATOR_LTE */); // Threshold operator: <=
    }
    if (isLocalComponent(3)) { /* Component COMPONENT_INSTANCE_ID_LIGHT1 */
      // Native, builtin wuobject, no need to create.
    }
    if (isLocalComponent(5)) { /* Component COMPONENT_INSTANCE_ID_ANDGATE1 */
      System.out.println("HASCENARIO INIT: Create and gate");
      WKPF.registerWuClass(VirtualANDGateWuObject.WUCLASS_AND_GATE, VirtualANDGateWuObject.properties);
      VirtualWuObject wuclassInstanceANDGate = new VirtualANDGateWuObject();
      WKPF.createWuObject((short)VirtualANDGateWuObject.WUCLASS_AND_GATE, getPortNumberForComponent(5), wuclassInstanceANDGate);
    }
    if (isLocalComponent(4)) { /* Component COMPONENT_INSTANCE_ID_OCCUPANCY1 */
      System.out.println("HASCENARIO INIT: Create occupancy sensor and set default value to occupied");
      WKPF.registerWuClass(VirtualOccupancySensorWuObject.WUCLASS_OCCUPANCY_SENSOR, VirtualOccupancySensorWuObject.properties);
      VirtualWuObject wuclassInstanceOccupancy = new VirtualOccupancySensorWuObject();
      WKPF.createWuObject((short)VirtualOccupancySensorWuObject.WUCLASS_OCCUPANCY_SENSOR, getPortNumberForComponent(4), wuclassInstanceOccupancy);
      WKPF.setPropertyBoolean(4, VirtualOccupancySensorWuObject.PROPERTY_OCCUPANCY_SENSOR_OCCUPIED, true); // Default: occupied
    }
    // =========== End: Generated by the translator from application WuML

    // =========== Begin: Constant part, not affected by the application.
    // ----- MAIN LOOP -----
    System.out.println("HAScenario - Entering main loop");
    while(true) {
      VirtualWuObject wuclass = WKPF.select();
      if (wuclass != null) {
        wuclass.update();
      }
      // =========== End: Constant part, not affected by the application.

      // =========== Begin: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
      if (isLocalComponent(COMPONENT_INSTANCE_ID_LIGHTSENSOR1)) { 
        tmpDummy += 1;
        System.out.println("HAScenario - updating dummy variable to trigger lightsensor update: " + tmpDummy);
        WKPF.setPropertyShort(COMPONENT_INSTANCE_ID_LIGHTSENSOR1, (byte)(WKPF.PROPERTY_LIGHT_SENSOR_CURRENT_VALUE+1), tmpDummy);
        System.out.println("HAScenario - updating dummy variable to trigger lightsensor update, result: " + WKPF.getErrorCode());
        if (WKPF.getErrorCode() != WKPF.OK)
          System.out.println("Error: " + WKPF.getErrorCode());
      }
      Timer.wait(1000);
      // =========== End: Temporarily write to a dummy property to trigger updates while don't have a scheduling mechanism yet.
    }
  }
}
